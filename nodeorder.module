<?php

/**
 * @file
 * Nodeorder module.
 */

use Drupal\Core\Cache\Cache;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\nodeorder\NodeOrderManager;
use Drupal\taxonomy\Entity\Vocabulary;

/**
 * {@defgroup module hooks
 * {@
 */

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_overview_terms().
 */
function nodeorder_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state) {
  $vocabulary = $form_state->get(['taxonomy', 'vocabulary']);
  if (!NodeOrderManager::vocabularyIsOrderable($vocabulary->id())) {
    return;
  }
  // This is a hack to include an 'order' link in the 'Operations' column, but
  // it is still not as bad a hack as copying/modifying core functions, which is
  // what we are trying to avoid.
  foreach ($form as $key => &$item) {
    if (strpos($key, 'tid') === 0) {
      // Copy the 'edit' link.
      $edit = $item['edit'];
      // Turn edit into something that can hold more items.
      $item['edit'] = array('#type' =>'item');
      // Add the 'edit' link back.
      $item['edit']['edit'] = $edit;
      // Add an 'order' link.
      $item['edit']['order'] = array(
        '#type' => 'link',
        '#title' => t('order'),
        '#href' => 'taxonomy/term/' . $item['#term']['tid'] . '/order',
        '#options' => array(
          'query' => drupal_get_destination(),
        ),
        '#attributes' => array(
          'class' => array('nodeorder-order-link'),
        ),
      );
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_form_vocabulary().
 */
function nodeorder_form_taxonomy_vocabulary_form_alter(&$form, FormStateInterface $form_state) {
  if ($form_state->get('confirm_delete')) {
    return;
  }
  $vocabulary = $form_state->getFormObject()->getEntity();

  $form['nodeorder'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node Order'),
    '#weight' => 1,
  );
  $form['nodeorder']['orderable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Orderable'),
    '#description' => t('If enabled, nodes may be ordered within this vocabulary.'),
    '#default_value' => NodeOrderManager::vocabularyIsOrderable($vocabulary->id()),
  );

  // Add a submit handler for saving the orderable settings.
  $form['actions']['submit']['#submit'][] = 'nodeorder_taxonomy_vocabulary_form_submit';
}

/**
 * Submit handler for nodeorder_form_taxonomy_vocabulary_form_alter().
 */
function nodeorder_taxonomy_vocabulary_form_submit($form, FormStateInterface $form_state) {
  $vocabulary = $form_state->getFormObject()->getEntity();
  $config = \Drupal::configFactory()->getEditable('nodeorder.settings');
  $orderable = $form_state->getValue('orderable');
  $vocabularies = $config->get('vocabularies');

  if ($orderable && empty($vocabularies[$vocabulary->id()])) {
    // Switching from non-orderable to orderable.
    Cache::invalidateTags(array('nodeorder'));

    // Set weight to nid for all rows in term_node where the tid is in this
    // vocabulary.
    $tree = \Drupal::entityManager()->getStorage("taxonomy_term")->loadTree($vocabulary->id());
    $tids = array();
    foreach ($tree as $term) {
      $tids[] = $term->tid;
    }

    if (count($tids) > 0) {
      $order = 'n.sticky DESC, tn0.weight';

      $tid = 0;
      $query_max = db_select('taxonomy_index', 'ti')
        ->condition('tid', $tid);
      $query_max->addExpression('MAX(weight)', 'mweight');

      foreach ($tids as $i => $tid) {
        // Select *current* nodes for the current term.
        // @todo: Replace this hacked function call.
        $result = NodeOrderManager::selectNodes(array($tid), 'and', 0, FALSE, $order, 0);

        foreach ($result as $node) {
          $max = $query_max->execute()->fetchField();
          $max = (int) $max + 1;
          db_update('taxonomy_index')
            ->condition('nid', $node->nid)
            ->condition('tid', $tid)
            ->fields(array('weight' => $max))
            ->execute();
        }
      }
    }

    drupal_set_message(t('You may now order nodes within this vocabulary.'));
  }
  elseif (!$orderable && !empty($vocabularies[$vocabulary->id()])) {
    // Switching from orderable to non-orderable.
    Cache::invalidateTags(array('nodeorder'));

    // Set weight to 0 for all rows in term_node where the tid is in this
    // vocabulary.
    $tree = \Drupal::entityManager()->getStorage("taxonomy_term")->loadTree($vocabulary->id());
    $tids = array();
    foreach ($tree as $term) {
      $tids[] = $term->tid;
    }

    if (count($tids) > 0) {
      db_update('taxonomy_index')
        ->fields(array('weight' => 0))
        ->condition('tid', $tids, 'IN')
        ->execute();
    }

    drupal_set_message(t('You may no longer order nodes within this vocabulary.'));
  }

  // Update config.
  $vocabularies[$vocabulary->id()] = $orderable;
  $config->set('vocabularies', $vocabularies);
  $config->save();
}

/**
 * Implements hook_node_view().
 */
function nodeorder_node_view(&$build, $node, $display, $view_mode) {
  $show_links = \Drupal::config('nodeorder.settings')->get('nodeorder_show_links_on_node');

  if (\Drupal::currentUser()->hasPermission('order nodes within categories') && $show_links) {
    // If this node belongs to any vocabularies that are orderable, stick a
    // couple links on per term to allow the user to move the node up or down
    // within the term.
    $results = db_select('taxonomy_index', 'ti')
      ->fields('ti', array('tid'))
      ->condition('nid', $node->id())
      ->execute();
    $terms = \Drupal\taxonomy\Entity\Term::loadMultiple($results->fetchCol());

    foreach ($terms as $term) {
      if (NodeOrderManager::vocabularyIsOrderable($term->getVocabularyId())) {

        nodeorder_add_links($node, $term);
      }
    }
  }
}

/**
 * Adds links to move node up or down in term.
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function nodeorder_add_links(&$node, $term) {
  $weights = NodeOrderManager::getTermMinMax($term->id());

  $weight = db_select('taxonomy_index', 'ti')
    ->fields('ti', array('weight'))
    ->condition('nid', $node->id())
    ->condition('tid', $term->id())
    ->execute()
    ->fetchField();

  // @todo: Links are not added to nodes in the same way; need to determine how to add these links to the node view
  // if ($weight > $weights['min']) {
  //   $node->content['links']['nodeorder_move_up_' . $term->tid] = array(
  //     '#weight' => 10,
  //     '#theme' => 'link',
  //     // @todo: This path does not actually exist.
  //     '#path' => 'nodeorder/moveup/' . $node->nid . '/' . $term->tid,
  //     '#text' => t('Move up in ' . $term->name),
  //     '#options' => array(
  //       'query' => drupal_get_destination(),
  //       'attributes' => array('title' => t('Move this ' . $node->type . ' up in its category.')),
  //       'html' => FALSE,
  //     ),
  //   );
  // }

  // if ($weight < $weights['max']) {
  //   $node->content['links']['nodeorder_move_down_' . $term->tid] = array(
  //     '#weight' => 10,
  //     '#theme' => 'link',
  //     // @todo: This path does not actually exist.
  //     '#path' => 'nodeorder/movedown/' . $node->nid . '/' . $term->tid,
  //     '#text' => t('Move down in ' . $term->name),
  //     '#options' => array(
  //       'query' => drupal_get_destination(),
  //       'attributes' => array('title' => t('Move this ' . $node->type . ' down in its category.')),
  //       'html' => FALSE,
  //     ),
  //   );
  // }
}

/**
 * Custom access function which determines whether or not the user is allowed
 * to reorder nodes and if the link should be shown at all.
 */
function nodeorder_order_access($tid) {
  return \Drupal::currentUser()->hasPermission('order nodes within categories')
    && \Drupal::config('nodeorder.settings')->get('link_to_ordering_page')
    && nodeorder_term_can_be_ordered($tid);
}

/**
 * Custom access function which determines whether or not the user is allowed
 * to reorder nodes and if the vocabulary is orderable.
 */
function nodeorder_taxonomy_order_access($vid) {
  return \Drupal::currentUser()->hasPermission('order nodes within categories') && \Drupal::config('nodeorder.settings')->get('nodeorder_link_to_ordering_page_taxonomy_admin') && NodeOrderManager::vocabularyIsOrderable($vid);
}

/**
 * Move a node up or down in its category.
 *
 * @todo: This function is never called.
 */
function nodeorder_move_in_category($direction, $nid, $tid) {
  // Note that it would be nice to wrap this in a transaction.
  $up = ($direction == 'moveup');
  $node = \Drupal::entityManager()->getStorage('node')->load($nid);
  $destination = isset($_GET['destination']) ? $_GET['destination'] : $_GET['q'];

  // Get the current weight for the node
  // @todo: db_select() or create a function as this exact query is repeated.
  $weight = db_query("SELECT weight FROM {taxonomy_index} WHERE nid = :nid AND tid = :tid", array(':nid' => $node->nid, ':tid' => $tid))->fetchField();

  if ($up) {
    $weights = NodeOrderManager::getTermMinMax($tid);
    if ($weight == $weights["min"]) {
      drupal_set_message(t('%title cannot be moved up as it already is at the top.', array('%title' => $node->title)), 'error');
      drupal_goto($destination);
      return;
    }

    // @todo: Covert to db_select().
    $sql = 'SELECT DISTINCT(n.nid), n.vid, tn.weight FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid = %d AND n.status = 1 AND tn.weight <= %d ORDER BY tn.weight DESC';
    $direction = 'up';
  }
  else {
    $weights = NodeOrderManager::getTermMinMax($tid);
    if ($weight == $weights["max"]) {
      drupal_set_message(t('%title cannot be moved down as it already is at the bottom.', array('%title' => $node->title)), 'error');
      drupal_goto($destination);
      return;
    }

    // @todo: Convert to db_select().
    $sql = 'SELECT DISTINCT(n.nid), n.vid, tn.weight FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid = %d AND n.status = 1 AND tn.weight >= %d ORDER BY tn.weight';
    $direction = 'down';
  }

  // @todo: Convert to db_select().
  $result = db_query_range('SELECT DISTINCT(n.nid), n.vid, tn.weight FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid = :tn.tid AND n.status = :n.status AND tn.weight >= :tn.weight ORDER BY tn.weight', array(':tn.tid' => $tid, ':n.status' => 1, ':tn.weight' => $weight));

  $node1 = db_fetch_object($result);
  $node2 = db_fetch_object($result);

  // Now we just need to swap the weights of the two nodes...
  if (!$node1 || !$node2) {
    drupal_set_message('There was a problem moving the node within its category.');
    drupal_access_denied();
    return;
  }

  $sql = "UPDATE {taxonomy_index} SET weight = %d WHERE nid = %d AND tid = %d";
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $node1->weight, $node2->nid, $tid) */
  db_update('taxonomy_term_node')
    ->fields(array('weight' => $node1->weight))
    ->condition('nid', $node2->nid)
    ->condition('tid', $tid)
    ->execute();
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $node2->weight, $node1->nid, $tid) */
  db_update('taxonomy_term_node')
    ->fields(array('weight' => $node2->weight))
    ->condition('nid', $node1->nid)
    ->condition('tid', $tid)
    ->execute();

  $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($tid);
  drupal_set_message(t("<em>%title</em> was moved $direction in %category...", array('%title' => $node->title, '%category' => $term->name)));

  // Now send user to the page they were on before.
  drupal_goto($_GET['destination']);
}

/**
 * Returns an array of the node's tids that are in orderable vocabularies.
 * Slower than nodeorder_orderable_tids but needed when tids have already been
 * removed from the database.
 *
 * Adopted form API function taxonomy_build_node_index().
 */
function nodeorder_orderable_tids_by_node(NodeInterface $node) {
  $tids = array();
  foreach ($node->getFieldDefinitions() as $field) {
    if ($field->getType() == 'entity_reference' && $field->getSetting('target_type') == 'taxonomy_term') {
      // If a field value is not set in the node object when node_save() is
      // called, the old value from $node->original is used.
      $field_name = $field->getName();
      foreach ($node->getTranslationLanguages() as $langcode) {
        $translated = $node->getTranslation($langcode->getId());
        foreach ($translated->{$field_name} as $item) {
          $term = $item->getValue();
          if (!empty($term['target_id'])) {
            $tids[$term['target_id']] = $term['target_id'];
          }
        }
      }
    }
  }

  return $tids;
}

/**
 * Returns TRUE if the term is in an orderable vocabulary.
 */
function nodeorder_term_can_be_ordered($tid) {
  $cid = 'nodeorder:term_can_be_ordered:' . $tid;

  if (($cache = cache_get($cid)) && !empty($cache->data)) {
    return $cache->data;
  }
  else {
    $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($tid);
    $term_can_be_ordered = NodeOrderManager::vocabularyIsOrderable($term->vid);

    // @todo: Why is this cached? Ordering is on a vocabulary level.
    // Permanently cache the value for easy reuse.
    cache_set($cid, $term_can_be_ordered, 'cache');

    return $term_can_be_ordered;
  }
}

/**
 * Implements hook_node_presave().
 */
function nodeorder_node_presave(NodeInterface $node) {
  if (NodeOrderManager::canBeOrdered($node)) {
    // Store the old node orders for use in nodeorder_node_update().
    $node->nodeorder = [];
    // When a node is created, store an element called 'nodeorder' that
    // contains an associative array of tid to weight.
    $query = db_select('taxonomy_index', 'ti')
      ->fields('ti', array('tid', 'weight'))
      ->condition('nid', $node->id());
    $result = $query->execute();
    foreach ($result as $term_node) {
      $node->nodeorder[$term_node->tid] = $term_node->weight;
    }
  }
}

/**
 * Implements hook_node_delete().
 *
 * Handle lists in which the node is removed.
 */
function nodeorder_node_delete(NodeInterface $node) {
  // Get tids from node var; in the database they're already removed.
  $tids = nodeorder_orderable_tids_by_node($node);
  foreach ($tids as $tid) {
    NodeOrderManager::handleListsDecrease($tid);
  }
}

/**
 * Implements hook_node_insert().
 *
 * Handle the weights of the node in the taxonomy orderable lists it id added.
 */
function nodeorder_node_insert(NodeInterface $node) {
  $tids = NodeOrderManager::getOrderableTids($node, TRUE);
  foreach ($tids as $tid) {
    NodeOrderManager::addToList($node, $tid);
  }
}

/**
 * Implements hook_node_update().
 *
 * Handle the weights, which were reset on rebuild of the taxonomy.
 */
function nodeorder_node_update(NodeInterface $node) {
  if (!NodeOrderManager::canBeOrdered($node)) {
    return;
  }
  $tids = NodeOrderManager::getOrderableTids($node, TRUE);
  $old_tids = $node->nodeorder;
  foreach ($tids as $tid) {
    // Restore weight of unchanged terms, or leave as is if zero.
    if (isset($old_tids[$tid])) {
      $old_weight = $old_tids[$tid];
      unset($old_tids[$tid]);

      if (!$old_weight) continue;
      db_update('taxonomy_index')
        ->fields(array('weight' => $old_weight))
        ->condition('nid', $node->id())
        ->condition('tid', $tid)
        ->execute();
    }
    // Push new or newly orderable node to top of ordered list.
    else {
      NodeOrderManager::addToList($node, $tid);
    }
  }

  // Handle lists in which the node is removed.
  // Note that the old tids are at this point only the ones that were not
  // updated, the others were dropped when restoring above.
  foreach ($old_tids as $tid => $weight) {
    NodeOrderManager::handleListsDecrease($tid);
  }

}

/**
 * Implements hook_help().
 */
function nodeorder_help($path, $arg) {
  switch ($path) {
    case 'taxonomy/term/%/order':
      $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($arg[2]);
      $output = '<p>' . t('This page provides a drag-and-drop interface for ordering nodes. To change the order of a node, grab a drag-and-drop handle under the <em>Node title</em> column and drag the node to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save order</em> button at the bottom of the page.') . '</p>';

      return $output;
    case 'admin/structure/taxonomy/%/order':
      $vocabulary = Vocabulary::load($arg[3]);
      $output = '<p>' . t('%capital_name is an orderable vocabulary. You may order the nodes associated with a term within this vocabulary by clicking the <em>order nodes</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name)));

      return $output;
  }
}

/**
 * @} End of "module hooks" defgroup
 */
