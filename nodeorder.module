<?php
// $Id$

/**
 * Implementation of hook_perm().
 */
function nodeorder_perm() {
  return array(
    'order nodes within categories'
  );
}

/**
 * Implementation of hook_help().
 */
function nodeorder_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      // This description is shown in the listing at admin/modules.
      return t('Allows the ordering of nodes within taxonomy terms.');
  }
}

/**
 * Implementation of hook_form_alter().
 */
function nodeorder_form_alter($form_id, &$form) {
  if ($form_id == 'taxonomy_form_vocabulary') {
    $is_orderable = $form['module']['#value'] == 'nodeorder';
    
    $form['orderable'] = array('#type' => 'checkbox',
      '#title' => t('Orderable'),
      '#description' => t('If enabled, nodes may be ordered within this vocabulary.'),
      '#weight' => 0.0085, // Try to have this show up after the 'Required' checkbox
      '#default_value' => $is_orderable
    );
    
    $form['#submit']['nodeorder_taxonomy_form_vocabulary_submit'] = array();
  }
}

/**
 * Accept the form submission for a vocabulary and save the results.
 */
function nodeorder_taxonomy_form_vocabulary_submit($form_id, $form_values) {
  $vid = $form_values['vid'];
  
  if ($form_values['orderable']) {
    if ($form_values['module'] != 'nodeorder') {
      // Switching from non-orderable to orderable...
      
      // Set weight_in_tid to nid for all rows in term_node where
      // the tid is in this vocabulary...
      $tree = taxonomy_get_tree($vid);
      
      $tids = array();
      
      foreach ($tree as $term) {
        $tids[] = $term->tid;
      }
      
      if (count($tids) > 0) {
        db_query("UPDATE {term_node} SET weight_in_tid = nid WHERE tid IN (" . implode(',', $tids) . ")");
      }
      
      db_query("UPDATE {vocabulary} SET module = '%s' WHERE vid = %d", 'nodeorder', $vid);

      drupal_set_message(t('You may now order nodes within this vocabulary.'));
    }
  }
  else {
    if ($form_values['module'] == 'nodeorder') {
      // Switching from orderable to non-orderable...
      db_query("UPDATE {vocabulary} SET module = '%s' WHERE vid = %d", 'taxonomy', $vid);
      
      // Set weight_in_tid to 0 for all rows in term_node where
      // the tid is in this vocabulary...
      $tree = taxonomy_get_tree($vid);
      
      $tids = array();
      
      foreach ($tree as $term) {
        $tids[] = $term->tid;
      }
      
      if (count($tids) > 0) {
        db_query("UPDATE {term_node} SET weight_in_tid = 0 WHERE tid IN (" . implode(',', $tids) . ")");
      }
      
      drupal_set_message(t('You may no longer order nodes within this vocabulary.'));
    }
  }
}

/**
 * Implementation of hook_link().
 */
function nodeorder_link($type, $node = 0, $main = 0) {
  $links = array();

  if (user_access('order nodes within categories') && variable_get('nodeorder_show_links_on_node', 1)) {
    // If this node belongs to any vocabularies that are orderable,
    // stick a couple links on per term to allow the user to move
    // the node up or down within the term...
    if ($type == 'node') {
      if (array_key_exists('taxonomy', $node)) {
        foreach ($node->taxonomy as $term) {
          $vocabulary = taxonomy_get_vocabulary($term->vid);
          if ($vocabulary->module == 'nodeorder') {
            $links[] = l(t('move up in %category', array('%category' => $term->name)), "nodeorder/moveup/$node->nid/$term->tid", array('title' => t('Move this %nodetype up in its category.', array('%nodetype' => $node->type)), 'class' => 'rubric-pe-move'), 'destination=' . $_GET['q']);
            $links[] = l(t('move down in %category', array('%category' => $term->name)), "nodeorder/movedown/$node->nid/$term->tid", array('title' => t('Move this %nodetype down in its category.', array('%nodetype' => $node->type)), 'class' => 'rubric-pe-move'), 'destination=' . $_GET['q']);
          }
        }
      }
    }
  }

  return $links;
}

/**
 * Implementation of hook_term_path() from Taxonomy.
 */
function nodeorder_term_path($term) {
  return 'nodeorder/term/'. $term->tid;
}

/**
 * Menu callback; displays all nodes associated with a term.
 */
function nodeorder_term_page($str_tids = '', $depth = 0, $op = 'page') {
  if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $str_tids)) {
    $operator = 'or';
    // The '+' character in a query string may be parsed as ' '.
    $tids = preg_split('/[+ ]/', $str_tids);
  }
  else if (preg_match('/^([0-9]+,)*[0-9]+$/', $str_tids)) {
    $operator = 'and';
    $tids = explode(',', $str_tids);
  }
  else {
    drupal_not_found();
  }

  if ($tids) {
    $result = db_query(db_rewrite_sql('SELECT t.tid, t.name FROM {term_data} t WHERE t.tid IN (%s)', 't', 'tid'), implode(',', $tids));
    $tids = array(); // we rebuild the $tids-array so it only contains terms the user has access to.
    $names = array();
    while ($term = db_fetch_object($result)) {
      $tids[] = $term->tid;
      $names[] = $term->name;
    }

    if ($names) {
      drupal_set_title($title = check_plain(implode(', ', $names)));
      
      // Set the order that gets passed in to taxonomy_select_nodes.
      // This probably breaks down when there's a query that spans
      // multiple terms...
      //
      // First sort by sticky, then by weight_in_tid...
      if ($operator == 'or') {
        $order = 'n.sticky DESC, tn.weight_in_tid';
      }
      else {
        $order = 'n.sticky DESC, tn0.weight_in_tid';
      }
      
      switch ($op) {
        case 'page':
          drupal_add_link(array('rel' => 'alternate',
                                'type' => 'application/rss+xml',
                                'title' => 'RSS - '. $title,
                                'href' => url('taxonomy/term/'. $str_tids .'/'. $depth .'/feed')));
    
          $output = '';
            
          // If there is only one term, then put a link on there
          // for administrators to allow them to order nodes in
          // the term...
          if (count($tids) == 1) {
            if (user_access('order nodes within categories') && variable_get('nodeorder_link_to_ordering_page', 1)) {
              $output .= theme('nodeorder_order_icon', 'nodeorder/order/' . $tids[0], $names[0]);
            }
          }

          $output .= taxonomy_render_nodes(taxonomy_select_nodes($tids, $operator, $depth, TRUE, $order));
          $output .= theme('feed_icon', url('taxonomy/term/'. $str_tids .'/'. $depth .'/feed'));
          return $output;
          break;

        case 'feed':
          $term = taxonomy_get_term($tids[0]);
          $channel['link'] = url('taxonomy/term/'. $str_tids .'/'. $depth, NULL, NULL, TRUE);
          $channel['title'] = variable_get('site_name', 'drupal') .' - '. $title;
          $channel['description'] = $term->description;

          $result = taxonomy_select_nodes($tids, $operator, $depth, FALSE, $order);
          node_feed($result, $channel);
          break;
        default:
          drupal_not_found();
      }
    }
    else {
      drupal_not_found();
    }
  }
}

/**
 * NOTE: This is nearly a direct copy of taxonomy_select_nodes() -- see
 *       http://drupal.org/node/25801 if you find this sort of copy and
 *       paste upsetting...
 * 
 * Finds all nodes that match selected taxonomy conditions.
 *
 * @param $tids
 *   An array of term IDs to match.
 * @param $operator
 *   How to interpret multiple IDs in the array. Can be "or" or "and".
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative
 *   integer or "all".
 * @param $pager
 *   Whether the nodes are to be used with a pager (the case on most Drupal
 *   pages) or not (in an XML feed, for example).
 * @param $order
 *   The order clause for the query that retrieve the nodes.
 * @param $count
 *   If $pager is TRUE, the number of nodes per page, or -1 to use the
 *   backward-compatible 'default_nodes_main' variable setting.  If $pager
 *   is FALSE, the total number of nodes to select; or -1 to use the
 *   backward-compatible 'feed_default_items' variable setting; or 0 to
 *   select all nodes.
 * @return
 *   A resource identifier pointing to the query results.
 */
function nodeorder_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC', $count = -1) {
  if (count($tids) > 0) {
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {
      $term = taxonomy_get_term($tid);
      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
    }

    if ($operator == 'or') {
      $str_tids = implode(',', call_user_func_array('array_merge', $descendant_tids));
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1 ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1';
    }
    else {
      $joins = '';
      $wheres = '';
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.nid = tn'. $index .'.nid';
        $wheres .= ' AND tn'. $index .'.tid IN ('. implode(',', $tids) .')';
      }
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 ' . $wheres;
    }
    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);
    if ($pager) {
      if ($count == -1) {
        $count = variable_get('default_nodes_main', 10);
      }
      $result = pager_query($sql, $count, 0, $sql_count);
    }
    else {
      if ($count == -1) {
        $count = variable_get('feed_default_items', 10);
      }
      
      if ($count == 0) {
        $result = db_query($sql);
      }
      else {
        $result = db_query_range($sql, 0, $count);
      }
    }
  }

  return $result;
}

function nodeorder_order_nodes($tid) {
  // We need the Scriptaculous and spajax CSS and JS...
  spajax_head();
  $noderorder_css = drupal_get_path('module', 'nodeorder') . '/nodeorder.css';
  theme_add_style($noderorder_css);
  
  $nids = array();
  $items = array();
  
  $order = 'n.sticky DESC, tn0.weight_in_tid';
  
  // Send 0 in as the count to nodeorder_select_nodes, which tells
  // it to put all the nodes (as opposed to some preconfigured number
  // of nodes) in the result set...
  $count = 0;
  $result = nodeorder_select_nodes(array($tid), 'and', 0, FALSE, $order, $count);
  if (db_num_rows($result) > 0) {
    $output = "<div id=\"node-sort-list\">\n";
    while ($node = db_fetch_object($result)) {
      $loaded_node = node_load($node->nid);
    
      $output .= "<div id=\"node_$node->nid\" class=\"sort-wrapper\">\n";

      $title_only_while_ordering =  variable_get('nodeorder_minimal_ordering_text', 0);
      
      if ($title_only_while_ordering) {
        $output .= "<div class=\"node node-shell\"><h2 class=\"title\">" . l($loaded_node->title, "node/$loaded_node->nid") . "</h2></div>\n";
      }
      else {
        $output .= node_view($loaded_node, 1);
      }
      
      $output .= "</div>\n";
      
      $nids[] = $node->nid;
      $weights[] = $loaded_node->nodeorder[$tid];
    }
    $output .= "\n</div>\n";
    
    drupal_set_html_head('<script type="text/javascript">var initialValues = ' . spajax_to_js($nids) . ';</script>');
    drupal_set_html_head('<script type="text/javascript">var initialWeights = ' . spajax_to_js($weights) . ';</script>');
    $onUpdate = "function (container) { var tid = $tid; var url = '/nodeorder/reordered'; new Ajax.Request(url, { method: 'post', postBody: Sortable.serialize(container.id)+'&initial-values='+initialValues+'&initial-weights='+initialWeights+'&tid='+tid } ); initialValues = Sortable.sequence(container.id); }";
    
    // Tell the Sortable that the child elements are DIVs with class="sort-wrapper"...
    $options = array('tag' => 'div',
      'only' => 'sort-wrapper',
      'handle' => 'title',
      '#onUpdate' => $onUpdate);
    spajax_sortable_element('node-sort-list', $options);
  }
  
  $term = taxonomy_get_term($tid);

  drupal_set_title(t('Set the order of nodes in ') . $term->name);
  return $output;
}

function nodeorder_reordered() {
  $tid = $_POST['tid'];
  $initial_order = split(',', $_POST['initial-values']);
  $initial_weights = split(',', $_POST['initial-weights']);
  $new_order = $_POST['node-sort-list'];
  
  $size = count($initial_order);
  
  $first = -1;
  $last = -1;
  
  // Go through the two arrays and find the first and
  // last different values...
  if (count($new_order) == $size) {
    for ($i = 0; $i < $size; $i++) {
      if ($initial_order[$i] != $new_order[$i]) {
        $first = $i;
        break;
      }
    }
    
    for ($i = $size - 1; $i > $first; $i--) {
      if ($initial_order[$i] != $new_order[$i]) {
        $last = $i;
        break;
      }
    }
    
    if ($last > $first) {
      // Go through all the nodes between the first
      // and last affected nodes and rearrange their
      // weight_in_tid values...
      //
      // We should have a transaction around this loop...
      for ($i = $first; $i <= $last; $i++) {
        $sql = "UPDATE {term_node} SET weight_in_tid = %d WHERE tid = %d AND nid = %d";
        db_query($sql, $initial_weights[$i], $tid, $new_order[$i]);
      }
    }
  }
}

/**
 * Implementation of hook_menu().
 */
function nodeorder_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'nodeorder/term',
      'title' => t('nodeorder term'),
      'callback' => 'nodeorder_term_page', // I want to call taxonomy_term_page but can't change the sort order...
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK);
    $items[] = array('path' => 'nodeorder/order',
      'title' => t('order'),
      'callback' => 'nodeorder_order_nodes',
      'access' => user_access('order nodes within categories'),
      'type' => MENU_CALLBACK);
    $items[] = array('path' => 'nodeorder/order',
      'title' => t('nodeorder order nodes'),
      'callback' => 'nodeorder_order_nodes',
      'access' => user_access('order nodes within categories'),
      'type' => MENU_CALLBACK);
    $items[] = array('path' => 'nodeorder/reordered',
      'title' => t('nodeorder reordered nodes'),
      'callback' => 'nodeorder_reordered',
      'access' => user_access('order nodes within categories'),
      'type' => MENU_CALLBACK);
  }
  else if ((arg(0) == 'nodeorder') && (arg(1) == 'moveup' || arg(1) == 'movedown') && is_numeric(arg(2)) && is_numeric(arg(3))) {
    $node = node_load(arg(2));
          
    $items[] = array('path' => 'nodeorder/moveup/' . $node->nid,
      'title' => t('Move Up'),
      'callback' => 'nodeorder_move_in_category',
      'callback arguments' => array($node, arg(3), true),
      'access' => user_access('order nodes within categories'),
      'type' => MENU_CALLBACK);
          
    $items[] = array('path' => 'nodeorder/movedown/' . $node->nid,
      'title' => t('Move Down'),
      'callback' => 'nodeorder_move_in_category',
      'callback arguments' => array($node, arg(3), false),
      'access' => user_access('order nodes within categories'),
      'type' => MENU_CALLBACK);
  }
  else if (is_numeric(arg(2))) {
      $items[] = array('path' => 'admin/taxonomy/' . arg(2) . '/order',
        'title' => t('order nodes'),
        'callback' => 'nodeorder_overview_terms',
        'callback arguments' => array(arg(2)),
        'access' => user_access('order nodes within categories') && nodeorder_vocabulary_can_be_ordered(arg(2)),
        'weight' => 5,
        'type' => MENU_LOCAL_TASK);
  }
  
  return $items;
}

/**
 * Move a node up or down in its category...
 */
function nodeorder_move_in_category(&$node, $tid, $up) {
  // Note that it would be nice to wrap this in a transaction...
  
  // We rely on the fact that every node has a unique weight_in_tid
  // (initially equal to negative one times its nid)...
  $weight = db_result(db_query("SELECT weight_in_tid FROM {term_node} WHERE nid = %d AND tid = %d", $node->nid, $tid));

  if ($up) {
    $sql = "SELECT nid, weight_in_tid FROM {term_node} WHERE tid = %d AND weight_in_tid <= %d ORDER BY weight_in_tid DESC LIMIT 2";
    $direction = 'up';
  }
  else {
    $sql = "SELECT nid, weight_in_tid FROM {term_node} WHERE tid = %d AND weight_in_tid >= %d ORDER BY weight_in_tid LIMIT 2";
    $direction = 'down';
  }

  $result = db_query($sql, $tid, $weight);
  
  // Now we just need to swap the weights of the two nodes...
  if (db_num_rows($result) != 2) {
    drupal_set_message('There was a problem moving the node within its category.');
    drupal_access_denied();
    return;
  }
  
  $node1 = db_fetch_object($result);
  $node2 = db_fetch_object($result);
  
  $sql = "UPDATE {term_node} SET weight_in_tid = %d WHERE nid = %d AND tid = %d";
  
  db_query($sql, $node1->weight_in_tid, $node2->nid, $tid);
  db_query($sql, $node2->weight_in_tid, $node1->nid, $tid);

  $term = taxonomy_get_term($tid);
  drupal_set_message(t("<em>%title</em> was moved $direction in %category...", array('%title' => $node->title, '%category' => $term->name)));
  
  // Now send user to the page they were on before...
  drupal_goto($_GET['destination']);
}

/**
 * Returns TRUE if the node has terms in any orderable vocabulary...
 */
function nodeorder_can_be_ordered($node) {
  $sql = "SELECT v.vid AS vid FROM {vocabulary_node_types} vnt JOIN {vocabulary} v ON vnt.vid = v.vid WHERE vnt.type = '%s' AND v.module = 'nodeorder'";
  $result = db_query($sql, $node->type);
  
  if (db_num_rows($result)) {
    return TRUE;
  }
  
  return FALSE;
}

/**
 * Returns an array of the node's tids that are in orderable vocabularies...
 */
function nodeorder_orderable_tids($node) {
  $tids = array();
  
  $sql = "SELECT v.vid AS vid FROM {vocabulary_node_types} vnt JOIN {vocabulary} v ON vnt.vid = v.vid WHERE vnt.type = '%s' AND v.module = 'nodeorder'";
  $result = db_query($sql, $node->type);
  
  while ($row = db_fetch_object($result)) {
    $tree = taxonomy_get_tree($row->vid);
    foreach ($tree as $term) {
      $tids[] = $term->tid;
    }
  }
  
  return $tids;
}

/**
 * Returns TRUE if the vocabulary is orderable...
 */
function nodeorder_vocabulary_can_be_ordered($vid) {
  $sql = "SELECT * FROM {vocabulary} WHERE module = 'nodeorder' AND vid = %d";
  $result = db_query($sql, $vid);
  
  if (db_num_rows($result)) {
    return TRUE;
  }
  
  return FALSE;
}

/**
 * Implementation of hook_nodeapi().
 */
function nodeorder_nodeapi($node, $op, $arg = 0) {
  if (nodeorder_can_be_ordered($node)) {    
    switch ($op) {
      case 'load':
        // When a node gets loaded, store an element called 'nodeorder' that contains
        // an associative array of tid to weight_in_tid...
        $output['nodeorder'] = array();
        $result = db_query('SELECT tid, weight_in_tid FROM {term_node} WHERE nid = %d', $node->nid);
        while ($term_node = db_fetch_object($result)) {
          $output['nodeorder'][$term_node->tid] = $term_node->weight_in_tid;
        }
        return $output;
      case 'insert':
        // Set the initial weight_in_tid to the node's nid...  Since this is a
        // new node, it is fine to set all the nid/tid combinations' weight_in_tid
        // to the same initial value for tids that are in orderable vocabularies.
        //
        // NOTE - fall through to 'update' since we do mostly the same thing there...
      case 'update':
        // Set the weight_in_tid -- taxonomy probably stomped it because
        // we added the weight_in_tid column to term_node, and taxonomy
        // just wants to delete and re-insert rows when things change...
        //
        // We start out by setting all the weight_in_tid values to the nid
        // because there may have been some additional tids for this node,
        // and their weight_in_tid values won't have been saved in $node->nodeorder...
        //
        // Note that we only want to set the weight_in_tid for tids that
        // are in orderable vocabularies...
        $tids = nodeorder_orderable_tids($node);
        
        if (count($tids) > 0) {
          $sql = "UPDATE {term_node} SET weight_in_tid = %d WHERE nid = %d AND tid IN (" . implode(',', $tids) . ")";
          db_query($sql, $node->nid, $node->nid);
        }

        // New nodes won't have any saved weight_in_tid values...
        if ($node->nodeorder) {
          // Restore any saved weight_in_tid values...
          foreach($node->nodeorder as $tid => $weight_in_tid) {
            $sql = "UPDATE {term_node} SET weight_in_tid = %d WHERE nid = %d AND tid = %d";
            db_query($sql, $weight_in_tid, $node->nid, $tid);
          }
        }        
        break;
    }
  }
}

function theme_nodeorder_order_icon($path, $name) {
  return '<div id="nodeorder-icon">' . l(t('Set the order of nodes in %term', array('%term' => $name)), $path) . "</div>\n";
}

/**
 * Implementation of hook_settings().
 */
function nodeorder_settings() {
  $form['nodeorder_show_links_on_node'] = array('#type' => 'checkbox',
    '#title' => t('Display ordering links on each node'),
    '#description' => t('If enabled, links will be added to each node that allow you to move the node up or down in each of its categories.'),
    '#default_value' => variable_get('nodeorder_show_links_on_node', 1)
  );

  $form['nodeorder_link_to_ordering_page'] = array('#type' => 'checkbox',
    '#title' => t('Display link to the ordering page'),
    '#description' => t('If enabled, a link will appear on all nodeorder/TID pages that quickly allows administrators to get to the node ordering administration page for the term.'),
    '#default_value' => variable_get('nodeorder_link_to_ordering_page', 1)
  );
 
  $form['nodeorder_minimal_ordering_text'] = array('#type' => 'checkbox',
    '#title' => t('Only show titles when ordering nodes'),
    '#description' => t('If enabled, only titles will be shown when ordering nodes within a category.  This allows you to see more nodes in a smaller amount of space.  It has no effect on the display of the same nodes in any other context.'),
    '#default_value' => variable_get('nodeorder_minimal_ordering_text', 0)
  );
  
  return $form;
}

/**
 * Display a tree of all the terms in a vocabulary, with options to
 * order nodes within each one.
 * 
 * This code was cut and pasted from taxonomy_overview_terms.  If
 * If we were able to add another operation onto each term on the
 * admin/taxonomy/VID page then we wouldn't even need this duplicate
 * function.
 * 
 * TODO - put in a patch for a taxonomy hook that lets us add
 *        admin operation links per term...
 */
function nodeorder_overview_terms($vid) {
  if (!nodeorder_vocabulary_can_be_ordered($vid)) {
    return t('This vocabulary is not orderable.  If you would like it to be orderable, check the Orderable box ') .
      l(t('here'), 'admin/taxonomy/edit/vocabulary' . $vid) . '.'; 
  }
  
  $header = array(t('Name'), t('Operations'));
  $vocabulary = taxonomy_get_vocabulary($vid);

  drupal_set_title(check_plain($vocabulary->name));
  $start_from      = $_GET['page'] ? $_GET['page'] : 0;
  $total_entries   = 0;  // total count for pager
  $page_increment  = 25; // number of tids per page
  $displayed_count = 0;  // number of tids shown

  $tree = taxonomy_get_tree($vocabulary->vid);
  foreach ($tree as $term) {
    $total_entries++; // we're counting all-totals, not displayed
    if (($start_from && ($start_from * $page_increment) >= $total_entries) || ($displayed_count == $page_increment)) { continue; }
    $rows[] = array(_taxonomy_depth($term->depth) . ' ' . l($term->name, "nodeorder/term/$term->tid"), l(t('order nodes'), "nodeorder/order/$term->tid"));
    $displayed_count++; // we're counting tids displayed
  }

  if (!$rows) {
    $rows[] = array(array('data' => t('No terms available.'), 'colspan' => '2'));
  }

  $GLOBALS['pager_page_array'][] = $start_from;  // FIXME
  $GLOBALS['pager_total'][] = intval($total_entries / $page_increment) + 1; // FIXME

  if ($total_entries >= $page_increment) {
    $rows[] = array(array('data' => theme('pager', NULL, $page_increment), 'colspan' => '2'));
  }

  return theme('table', $header, $rows, array('id' => 'taxonomy'));
}
