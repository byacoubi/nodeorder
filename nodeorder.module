<?php

/**
 * @file
 * Nodeorder module.
 */

use Drupal\Core\Cache\Cache;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\Entity\Vocabulary;

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_overview_terms().
 */
function nodeorder_form_taxonomy_overview_terms_alter(&$form, FormStateInterface $form_state) {
  $vocabulary = $form_state->get(['taxonomy', 'vocabulary']);
  if (!nodeorder_is_orderable_vocabulary($vocabulary->id())) {
    return;
  }
  // This is a hack to include an 'order' link in the 'Operations' column, but
  // it is still not as bad a hack as copying/modifying core functions, which is
  // what we are trying to avoid.
  foreach ($form as $key => &$item) {
    if (strpos($key, 'tid') === 0) {
      // Copy the 'edit' link.
      $edit = $item['edit'];
      // Turn edit into something that can hold more items.
      $item['edit'] = array('#type' =>'item');
      // Add the 'edit' link back.
      $item['edit']['edit'] = $edit;
      // Add an 'order' link.
      $item['edit']['order'] = array(
        '#type' => 'link',
        '#title' => t('order'),
        '#href' => 'taxonomy/term/' . $item['#term']['tid'] . '/order',
        '#options' => array(
          'query' => drupal_get_destination(),
        ),
        '#attributes' => array(
          'class' => array('nodeorder-order-link'),
        ),
      );
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_form_vocabulary().
 */
function nodeorder_form_taxonomy_vocabulary_form_alter(&$form, FormStateInterface $form_state) {
  if ($form_state->get('confirm_delete')) {
    return;
  }
  $vocabulary = $form_state->getFormObject()->getEntity();

  $form['nodeorder'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node Order'),
    '#weight' => 1,
  );
  $form['nodeorder']['orderable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Orderable'),
    '#description' => t('If enabled, nodes may be ordered within this vocabulary.'),
    '#default_value' => nodeorder_is_orderable_vocabulary($vocabulary->id()),
  );

  // Add a submit handler for saving the orderable settings.
  $form['actions']['submit']['#submit'][] = 'nodeorder_taxonomy_vocabulary_form_submit';
}

/**
 * Submit handler for nodeorder_form_taxonomy_vocabulary_form_alter().
 */
function nodeorder_taxonomy_vocabulary_form_submit($form, FormStateInterface $form_state) {
  $vocabulary = $form_state->getFormObject()->getEntity();
  $config = \Drupal::configFactory()->getEditable('nodeorder.settings');
  $orderable = $form_state->getValue('orderable');
  $vocabularies = $config->get('vocabularies');

  if ($orderable && empty($vocabularies[$vocabulary->id()])) {
    // Switching from non-orderable to orderable.
    Cache::invalidateTags(array('nodeorder'));

    // Set weight to nid for all rows in term_node where the tid is in this
    // vocabulary.
    $tree = \Drupal::entityManager()->getStorage("taxonomy_term")->loadTree($vocabulary->id());
    $tids = array();
    foreach ($tree as $term) {
      $tids[] = $term->tid;
    }

    if (count($tids) > 0) {
      $order = 'n.sticky DESC, tn0.weight';

      $tid = 0;
      $query_max = db_select('taxonomy_index', 'ti')
        ->condition('tid', $tid);
      $query_max->addExpression('MAX(weight)', 'mweight');

      foreach ($tids as $i => $tid) {
        // Select *current* nodes for the current term.
        // @todo: Replace this hacked function call.
        $result = nodeorder_select_nodes(array($tid), 'and', 0, FALSE, $order, 0);

        foreach ($result as $node) {
          $max = $query_max->execute()->fetchField();
          $max = (int) $max + 1;
          db_update('taxonomy_index')
            ->condition('nid', $node->nid)
            ->condition('tid', $tid)
            ->fields(array('weight' => $max))
            ->execute();
        }
      }
    }

    drupal_set_message(t('You may now order nodes within this vocabulary.'));
  }
  elseif (!$orderable && !empty($vocabularies[$vocabulary->id()])) {
    // Switching from orderable to non-orderable.
    Cache::invalidateTags(array('nodeorder'));

    // Set weight to 0 for all rows in term_node where the tid is in this
    // vocabulary.
    $tree = \Drupal::entityManager()->getStorage("taxonomy_term")->loadTree($vocabulary->id());
    $tids = array();
    foreach ($tree as $term) {
      $tids[] = $term->tid;
    }

    if (count($tids) > 0) {
      db_update('taxonomy_index')
        ->fields(array('weight' => 0))
        ->condition('tid', $tids, 'IN')
        ->execute();
    }

    drupal_set_message(t('You may no longer order nodes within this vocabulary.'));
  }

  // Update config.
  $vocabularies[$vocabulary->id()] = $orderable;
  $config->set('vocabularies', $vocabularies);
  $config->save();
}

/**
 * Implements hook_node_view().
 */
function nodeorder_node_view(&$build, $node, $display, $view_mode) {
  $show_links = \Drupal::config('nodeorder.settings')->get('nodeorder_show_links_on_node');

  if (\Drupal::currentUser()->hasPermission('order nodes within categories') && $show_links) {
    // If this node belongs to any vocabularies that are orderable, stick a
    // couple links on per term to allow the user to move the node up or down
    // within the term.
    $results = db_select('taxonomy_index', 'ti')
      ->fields('ti', array('tid'))
      ->condition('nid', $node->id())
      ->execute();
    $terms = \Drupal\taxonomy\Entity\Term::loadMultiple($results->fetchCol());

    foreach ($terms as $term) {
      if (nodeorder_vocabulary_can_be_ordered($term->getVocabularyId())) {

        nodeorder_add_links($node, $term);
      }
    }
  }
}

/**
 * Adds links to move node up or down in term.
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function nodeorder_add_links(&$node, $term) {
  $weights = nodeorder_get_term_min_max($term->id());

  $weight = db_select('taxonomy_index', 'ti')
    ->fields('ti', array('weight'))
    ->condition('nid', $node->id())
    ->condition('tid', $term->id())
    ->execute()
    ->fetchField();

  // @todo: Links are not added to nodes in the same way; need to determine how to add these links to the node view
  // if ($weight > $weights['min']) {
  //   $node->content['links']['nodeorder_move_up_' . $term->tid] = array(
  //     '#weight' => 10,
  //     '#theme' => 'link',
  //     // @todo: This path does not actually exist.
  //     '#path' => 'nodeorder/moveup/' . $node->nid . '/' . $term->tid,
  //     '#text' => t('Move up in ' . $term->name),
  //     '#options' => array(
  //       'query' => drupal_get_destination(),
  //       'attributes' => array('title' => t('Move this ' . $node->type . ' up in its category.')),
  //       'html' => FALSE,
  //     ),
  //   );
  // }

  // if ($weight < $weights['max']) {
  //   $node->content['links']['nodeorder_move_down_' . $term->tid] = array(
  //     '#weight' => 10,
  //     '#theme' => 'link',
  //     // @todo: This path does not actually exist.
  //     '#path' => 'nodeorder/movedown/' . $node->nid . '/' . $term->tid,
  //     '#text' => t('Move down in ' . $term->name),
  //     '#options' => array(
  //       'query' => drupal_get_destination(),
  //       'attributes' => array('title' => t('Move this ' . $node->type . ' down in its category.')),
  //       'html' => FALSE,
  //     ),
  //   );
  // }
}

/**
 * Get the minimum and maximum weights available for ordering nodes on a term.
 *
 * @param int $tid
 *   The tid of the term from which to check values.
 * @param bool $reset
 *   (optional) Select from or reset the cache.
 *
 * @return array
 *   An associative array with elements 'min' and 'max'.
 */
function nodeorder_get_term_min_max($tid, $reset = FALSE) {
  static $min_weights = array();
  static $max_weights = array();

  if ($reset) {
    $min_weights = array();
    $max_weights = array();
  }

  if (!isset($min_weights[$tid]) || !isset($max_weights[$tid])) {
    $query = db_select('taxonomy_index', 'i')
      ->fields('i', array('tid'))
      ->condition('tid', $tid)
      ->groupBy('tid');
    $query->addExpression('MAX(weight)', 'max_weight');
    $query->addExpression('MIN(weight)', 'min_weight');
    $record = $query->execute()->fetch();

    $min_weights[$tid] = $record->min_weight;
    $max_weights[$tid] = $record->max_weight;
  }

  $weights['min'] = $min_weights[$tid];
  $weights['max'] = $max_weights[$tid];

  return $weights;
}

/**
 * Determines if a given vocabulary is orderable.
 *
 * @param string $vid
 *   The vocabulary vid.
 *
 * @return bool
 *   Returns TRUE if the given vocabulary is orderable.
 */
function nodeorder_is_orderable_vocabulary($vid) {
  $vocabularies = \Drupal::config('nodeorder.settings')->get('vocabularies');
  return !empty($vocabularies[$vid]);
}

/**
 * Custom access function which determines whether or not the user is allowed
 * to reorder nodes and if the link should be shown at all.
 */
function nodeorder_order_access($tid) {
  return \Drupal::currentUser()->hasPermission('order nodes within categories')
    && \Drupal::config('nodeorder.settings')->get('link_to_ordering_page')
    && nodeorder_term_can_be_ordered($tid);
}

/**
 * Custom access function which determines whether or not the user is allowed
 * to reorder nodes and if the vocabulary is orderable.
 */
function nodeorder_taxonomy_order_access($vid) {
  return \Drupal::currentUser()->hasPermission('order nodes within categories') && \Drupal::config('nodeorder.settings')->get('nodeorder_link_to_ordering_page_taxonomy_admin') && nodeorder_vocabulary_can_be_ordered($vid);
}

/**
 * NOTE: This is nearly a direct copy of taxonomy_select_nodes() -- see
 *       http://drupal.org/node/25801 if you find this sort of copy and
 *       paste upsetting...
 *
 * Finds all nodes that match selected taxonomy conditions.
 *
 * @param $tids
 *   An array of term IDs to match.
 * @param $operator
 *   How to interpret multiple IDs in the array. Can be "or" or "and".
 * @param $depth
 *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative
 *   integer or "all".
 * @param $pager
 *   Whether the nodes are to be used with a pager (the case on most Drupal
 *   pages) or not (in an XML feed, for example).
 * @param $order
 *   The order clause for the query that retrieve the nodes.
 * @param $count
 *   If $pager is TRUE, the number of nodes per page, or -1 to use the
 *   backward-compatible 'default_nodes_main' variable setting.  If $pager
 *   is FALSE, the total number of nodes to select; or -1 to use the
 *   backward-compatible 'feed_default_items' variable setting; or 0 to
 *   select all nodes.
 * @return
 *   A resource identifier pointing to the query results.
 */
function nodeorder_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC', $count = -1) {
  if (count($tids) > 0) {
    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {
      $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($tid);
      $tree = \Drupal::entityManager()->getStorage("taxonomy_term")->loadTree($term->getVocabularyId(), $tid, $depth);
      $descendant_tids[] = array_merge(array($tid), array_map(function ($value) { return $value->id(); }, $tree));
    }

    if ($operator == 'or') {
      $args = call_user_func_array('array_merge', $descendant_tids);
      $placeholders = db_placeholders($args, 'int');
      $sql = 'SELECT DISTINCT(n.nid), nd.sticky, nd.title, nd.created, tn.weight FROM {node} n LEFT JOIN {node_field_data} nd INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1 ORDER BY ' . $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid IN (' . $placeholders . ') AND n.status = 1';
    }
    else {
      $joins = '';
      $wheres = '';
      $args = array();
      $query = db_select('node', 'n');
      $query->join('node_field_data', 'nd');
      $query->condition('nd.status', 1);
      foreach ($descendant_tids as $index => $tids) {
        $query->join('taxonomy_index', "tn$index", "n.nid = tn{$index}.nid");
        $query->condition("tn{$index}.tid", $tids, 'IN');
      }
      $query->fields('nd', array('nid', 'sticky', 'title', 'created'));
      // @todo: distinct?
      $query->fields('tn0', array('weight'));
      // @todo: ORDER BY ' . $order;
      //$sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n ' . $joins . ' WHERE n.status = 1 ' . $wheres;
    }

    if ($pager) {
      if ($count == -1) {
        $count = \Drupal::config('nodeorder.settings')->get('default_nodes_main');
      }
      $result = pager_query($sql, $count, 0, $sql_count, $args);
    }
    else {
      if ($count == -1) {
        $count = \Drupal::config('nodeorder.settings')->get('feed_default_items');
      }

      if ($count == 0) {
        // TODO Please convert this statement to the D7 database API syntax.
        $result = $query->execute();
      }
      else {
        // TODO Please convert this statement to the D7 database API syntax.
        $result = db_query_range($sql, $args);
      }
    }
  }

  return $result;
}

/**
 * Move a node up or down in its category.
 *
 * @todo: This function is never called.
 */
function nodeorder_move_in_category($direction, $nid, $tid) {
  // Note that it would be nice to wrap this in a transaction.
  $up = ($direction == 'moveup');
  $node = \Drupal::entityManager()->getStorage('node')->load($nid);
  $destination = isset($_GET['destination']) ? $_GET['destination'] : $_GET['q'];

  // Get the current weight for the node
  // @todo: db_select() or create a function as this exact query is repeated.
  $weight = db_query("SELECT weight FROM {taxonomy_index} WHERE nid = :nid AND tid = :tid", array(':nid' => $node->nid, ':tid' => $tid))->fetchField();

  if ($up) {
    $weights = nodeorder_get_term_min_max($tid);
    if ($weight == $weights["min"]) {
      drupal_set_message(t('%title cannot be moved up as it already is at the top.', array('%title' => $node->title)), 'error');
      drupal_goto($destination);
      return;
    }

    // @todo: Covert to db_select().
    $sql = 'SELECT DISTINCT(n.nid), n.vid, tn.weight FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid = %d AND n.status = 1 AND tn.weight <= %d ORDER BY tn.weight DESC';
    $direction = 'up';
  }
  else {
    $weights = nodeorder_get_term_min_max($tid);
    if ($weight == $weights["max"]) {
      drupal_set_message(t('%title cannot be moved down as it already is at the bottom.', array('%title' => $node->title)), 'error');
      drupal_goto($destination);
      return;
    }

    // @todo: Convert to db_select().
    $sql = 'SELECT DISTINCT(n.nid), n.vid, tn.weight FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid = %d AND n.status = 1 AND tn.weight >= %d ORDER BY tn.weight';
    $direction = 'down';
  }

  // @todo: Convert to db_select().
  $result = db_query_range('SELECT DISTINCT(n.nid), n.vid, tn.weight FROM {node} n INNER JOIN {taxonomy_index} tn ON n.vid = tn.vid WHERE tn.tid = :tn.tid AND n.status = :n.status AND tn.weight >= :tn.weight ORDER BY tn.weight', array(':tn.tid' => $tid, ':n.status' => 1, ':tn.weight' => $weight));

  $node1 = db_fetch_object($result);
  $node2 = db_fetch_object($result);

  // Now we just need to swap the weights of the two nodes...
  if (!$node1 || !$node2) {
    drupal_set_message('There was a problem moving the node within its category.');
    drupal_access_denied();
    return;
  }

  $sql = "UPDATE {taxonomy_index} SET weight = %d WHERE nid = %d AND tid = %d";
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $node1->weight, $node2->nid, $tid) */
  db_update('taxonomy_term_node')
    ->fields(array('weight' => $node1->weight))
    ->condition('nid', $node2->nid)
    ->condition('tid', $tid)
    ->execute();
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $node2->weight, $node1->nid, $tid) */
  db_update('taxonomy_term_node')
    ->fields(array('weight' => $node2->weight))
    ->condition('nid', $node1->nid)
    ->condition('tid', $tid)
    ->execute();

  $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($tid);
  drupal_set_message(t("<em>%title</em> was moved $direction in %category...", array('%title' => $node->title, '%category' => $term->name)));

  // Now send user to the page they were on before.
  drupal_goto($_GET['destination']);
}

/**
 * Returns TRUE if the node has terms in any orderable vocabulary.
 */
function nodeorder_can_be_ordered(NodeInterface $node) {
  $cid = 'nodeorder:can_be_ordered:' . $node->getType();

  if (($cache = \Drupal::cache()->get($cid)) && !empty($cache->data)) {
    return $cache->data;
  }
  else {
    $can_be_ordered = FALSE;

    $nodeorder_vocabularies = [];
    foreach ($node->getFieldDefinitions() as $field) {
      if ($field->getType() != 'entity_reference' || $field->getSetting('target_type') != 'taxonomy_term') {
        continue;
      }

      foreach ($field->getSetting('handler_settings')['target_bundles'] as $vocabulary) {
        $nodeorder_vocabularies[] = $vocabulary;
      }
    }

    foreach ($nodeorder_vocabularies as $vid) {
      if (Vocabulary::load($vid)) {
        $can_be_ordered = TRUE;
      }
    }

    // Permanently cache the value for easy reuse.
    \Drupal::cache()->set($cid, $can_be_ordered, Cache::PERMANENT, array('nodeorder'));

    return $can_be_ordered;
  }
}

/**
 * Returns an array of the node's tids that are in orderable vocabularies.
 */
function nodeorder_orderable_tids(NodeInterface $node, $reset = FALSE) {
  $cid = 'nodeorder:orderable_tids:' . $node->getType();

  if (!$reset && ($cache = \Drupal::cache()->get($cid)) && !empty($cache->data)) {
    $tids = $cache->data;
  }
  else {
    $vocabularies = array();
    foreach (\Drupal::config('nodeorder.settings')->get('vocabularies') as $vid => $orderable) {
      if ($orderable) {
        $vocabularies[] = $vid;
      }
    }
    if (!empty($vocabularies)) {
      $query = db_select('taxonomy_index', 'i');
      $query->join('taxonomy_term_data', 'd', 'd.tid = i.tid');
      $query->condition('i.nid', $node->id())
        ->condition('d.vid', $vocabularies, 'IN')
        ->fields('i', array('tid'));
      $tids = $query->execute()->fetchCol('tid');
    }
    else {
      $tids = array();
    }
    // Permanently cache the value for easy reuse.
    // @todo this needs to properly clear when node is edited.
    \Drupal::cache()->set($cid, $tids, Cache::PERMANENT, array('nodeorder'));
  }

  return $tids;
}

/**
 * Returns an array of the node's tids that are in orderable vocabularies.
 * Slower than nodeorder_orderable_tids but needed when tids have already been
 * removed from the database.
 *
 * Adopted form API function taxonomy_build_node_index().
 */
function nodeorder_orderable_tids_by_node(NodeInterface $node) {
  $tids = array();
  foreach ($node->getFieldDefinitions() as $field) {
    if ($field->getType() == 'entity_reference' && $field->getSetting('target_type') == 'taxonomy_term') {
      // If a field value is not set in the node object when node_save() is
      // called, the old value from $node->original is used.
      $field_name = $field->getName();
      foreach ($node->getTranslationLanguages() as $langcode) {
        $translated = $node->getTranslation($langcode->getId());
        foreach ($translated->{$field_name} as $item) {
          $term = $item->getValue();
          if (!empty($term['target_id'])) {
            $tids[$term['target_id']] = $term['target_id'];
          }
        }
      }
    }
  }

  return $tids;
}

/**
 * Returns TRUE if the vocabulary is orderable.
 */
function nodeorder_vocabulary_can_be_ordered($vid) {
  // @todo: The taxonomy_vocabulary table doesn't exist, so need to find another way to determine if this vocabulary is sortable or not
  return TRUE;

  $result = db_select('taxonomy_vocabulary', 'v')
    ->fields('v')
    ->condition('v.module', 'nodeorder')
    ->condition('v.vid', $vid)
    ->execute();

  if ($result->fetchAssoc()) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Returns TRUE if the term is in an orderable vocabulary.
 */
function nodeorder_term_can_be_ordered($tid) {
  $cid = 'nodeorder:term_can_be_ordered:' . $tid;

  if (($cache = cache_get($cid)) && !empty($cache->data)) {
    return $cache->data;
  }
  else {
    $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($tid);
    $term_can_be_ordered = nodeorder_vocabulary_can_be_ordered($term->vid);

    // @todo: Why is this cached? Ordering is on a vocabulary level.
    // Permanently cache the value for easy reuse.
    cache_set($cid, $term_can_be_ordered, 'cache');

    return $term_can_be_ordered;
  }
}

/**
 * Implements hook_node_presave().
 */
function nodeorder_node_presave(NodeInterface $node) {
  if (nodeorder_can_be_ordered($node)) {
    // Store the old node orders for use in nodeorder_node_update().
    $node->nodeorder = [];
    // When a node is created, store an element called 'nodeorder' that
    // contains an associative array of tid to weight.
    $query = db_select('taxonomy_index', 'ti')
      ->fields('ti', array('tid', 'weight'))
      ->condition('nid', $node->id());
    $result = $query->execute();
    foreach ($result as $term_node) {
      $node->nodeorder[$term_node->tid] = $term_node->weight;
    }
  }
}

/**
 * Implements hook_node_delete().
 *
 * Handle lists in which the node is removed.
 */
function nodeorder_node_delete(NodeInterface $node) {
  // Get tids from node var; in the database they're already removed.
  $tids = nodeorder_orderable_tids_by_node($node);
  foreach ($tids as $tid) {
    nodeorder_handle_node_lists_decrease($tid);
  }
}

/**
 * Implements hook_node_insert().
 *
 * Handle the weights of the node in the taxonomy orderable lists it id added.
 */
function nodeorder_node_insert($node) {
  $tids = nodeorder_orderable_tids($node, TRUE);
  foreach ($tids as $tid) {
    nodeorder_add_node_to_list($node, $tid);
  }
}

/**
 * Implements hook_node_update().
 *
 * Handle the weights, which were reset on rebuild of the taxonomy.
 */
function nodeorder_node_update(NodeInterface $node) {
  if (!nodeorder_can_be_ordered($node)) {
    return;
  }
  $tids = nodeorder_orderable_tids($node, TRUE);
  $old_tids = $node->nodeorder;
  foreach ($tids as $tid) {
    // Restore weight of unchanged terms, or leave as is if zero.
    if (isset($old_tids[$tid])) {
      $old_weight = $old_tids[$tid];
      unset($old_tids[$tid]);

      if (!$old_weight) continue;
      db_update('taxonomy_index')
        ->fields(array('weight' => $old_weight))
        ->condition('nid', $node->id())
        ->condition('tid', $tid)
        ->execute();
    }
    // Push new or newly orderable node to top of ordered list.
    else {
      nodeorder_add_node_to_list($node, $tid);
    }
  }

  // Handle lists in which the node is removed.
  // Note that the old tids are at this point only the ones that were not
  // updated, the others were dropped when restoring above.
  foreach ($old_tids as $tid => $weight) {
    nodeorder_handle_node_lists_decrease($tid);
  }

}

/**
 * Push new or newly orderable node to top of ordered list.
 */
function nodeorder_add_node_to_list($node, $tid) {
  // Append new orderable node.
  $weights = nodeorder_get_term_min_max($tid); // Get the cached weights.
  db_update('taxonomy_index')
    ->fields(array('weight' => $weights['min'] - 1))
    ->condition('nid', $node->id())
    ->condition('tid', $tid)
    ->execute();
  // If new node out of range, push top nodes down filling the order gap
  // this is when old list's min weight is top range
  // except when new orderable node increases range (new list is not even).
  $taxonomy_nids = db_select('taxonomy_index', 'ti')
    ->fields('ti', array('nid'))
    ->condition('ti.tid', $tid)
    ->orderBy('ti.weight')
    ->execute()
    ->fetchCol('nid');

  $new_node_out_of_range = (count($taxonomy_nids) % 2 == 0 && $weights['min'] == -ceil(count($taxonomy_nids) / 2));
  if ($new_node_out_of_range) {
    // Collect top nodes.
    // Note that while the node data is not yet updated in the database, the taxonomy is.
    $top_range_nids = array();
    $previous_weight = $weights['min'] - 2;
    foreach ($taxonomy_nids as $taxonomy_nid) {
      $taxonomy_node_weight = db_select('taxonomy_index', 'i')
        ->fields('i', array('weight'))
        ->condition('tid', $tid)
        ->condition('nid', $taxonomy_nid)
        ->execute()
        ->fetchField();

      if ($taxonomy_node_weight > $previous_weight + 1)  break;
      $previous_weight = $taxonomy_node_weight;
      $top_range_nids[] = $taxonomy_nid;
    }
    // Move top nodes down.
    $query = db_update('taxonomy_index');
    $query->expression('weight', 'weight + 1');
    $query->condition('nid', $top_range_nids, 'IN')
          ->condition('tid', $tid)
          ->execute();
  }
  // Make sure the weight cache is invalidated.
  nodeorder_get_term_min_max($tid, TRUE);
}

/**
 * Reorder list in which the node is dropped and where the borders became out
 * of range.
 */
function nodeorder_handle_node_lists_decrease($tid) {
  $taxonomy_nids = db_select('taxonomy_index', 'ti')
    ->fields('ti', array('nid'))
    ->condition('ti.tid', $tid)
    ->orderBy('ti.weight')
    ->execute()
    ->fetchCol('nid');
  if (!count($taxonomy_nids)) {
    return;
  }
  $weights = nodeorder_get_term_min_max($tid, TRUE);
  $range_border = ceil(count($taxonomy_nids) / 2);
  // Out of range when one of both new list's border weights is corresponding range border.
  $border_out_of_range = ($weights['min'] < -$range_border || $weights['max'] > $range_border);
  if ($border_out_of_range) {
    $weight = -$range_border;
    foreach ($taxonomy_nids as $nid) {
      $query = db_update('taxonomy_index')
        ->fields(array('weight' => $weight))
        ->condition('nid', $nid)
        ->condition('tid', $tid)
        ->execute();
      $weight ++;
    }
    // Make sure the weight cache is invalidated.
    nodeorder_get_term_min_max($tid, TRUE);
  }
}

/**
 * Implements hook_help().
 */
function nodeorder_help($path, $arg) {
  switch ($path) {
    case 'taxonomy/term/%/order':
      $term = \Drupal::entityManager()->getStorage('taxonomy_term')->load($arg[2]);
      $output = '<p>' . t('This page provides a drag-and-drop interface for ordering nodes. To change the order of a node, grab a drag-and-drop handle under the <em>Node title</em> column and drag the node to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save order</em> button at the bottom of the page.') . '</p>';

      return $output;
    case 'admin/structure/taxonomy/%/order':
      $vocabulary = Vocabulary::load($arg[3]);
      $output = '<p>' . t('%capital_name is an orderable vocabulary. You may order the nodes associated with a term within this vocabulary by clicking the <em>order nodes</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name)));

      return $output;
  }
}
